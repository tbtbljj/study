# 宽度优先搜索(Breadth First Search, BFS)

* 大纲(Outline)
  * 二叉树上的宽搜(BFS in binary tree)
    * 树是图的一种特殊形态，树属于图
  * 图上的宽搜(BFS in graph)
    * 拓扑排序(topological sorting)
  * 棋盘上的宽搜
* 使用`BFS`的常见场景
  * 图的遍历(Traversal In Graph)
    * 层级遍历(Level Order Traversal)
    * 由点及面(Connected Component)
    * 拓扑排序(Topological Sorting)
  * 最短路径(Shortest Path In Simple Graph)
    * 仅限简单图(每条边长度为1且没有方向)求最短路径
* `BFS`要点
  * 使用**队列**(`queue`)作为主要的数据结构
  * 是否分层
    * 分层的算法比不分层的算法多一个循环
  * `int size = queue.size();`
* 序列化
  * 定义
    * 将**内存**中结构化的数据变成**字符串**的过程
    * object to string
  * 反序列化：string to object
  * 常见的序列化场景
    * 持久化存储内存中的数据
    * 网络传输
  * 常见的序列化手段
    * `xml`
    * `json`
    * `thrift`(by facebook)
    * `protobuf`(by google)
  * 序列化算法
    * 例子
      * 一个整数数组，可以序列化为"[1,2,3]"
      * 一个整数链表，可以序列化为"1->2->3"
      * 一个哈希表，可以序列化为"{\\"key\\":\\"value\\"}"
    * 考虑因素
      * 压缩率
        * 网络传输和磁盘存储
        * 如，`thrift`和`protobuf`都是为了更快地传输数据和节省存储空间而设计的
      * 可读性
        * 能够通过序列化的数据直接看懂原始数据
        * 如，`json`
    * 二叉树序列化
      * 如，使用`BFS`对二叉树数据进行序列化，好处是可以容易地画出整棵二叉树
* 图上的宽搜
  * 区别于树上的宽搜
    * 图中存在**环**
    * 图中同一个节点可能**重复**进入队列
  * `hashmap`
