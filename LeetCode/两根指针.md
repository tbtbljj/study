# 两根指针(Two Pointers)

* 大纲(Outline)
  * Partition
    * Quick Select
    * 分成两个部分
    * 分成三个部分
    * 一些没听过的(但是面试会考的)排序算法
  * Two Sum
    * 几乎所有Two Sum变种
* 分类
  * 同向双指针
  * 相向双指针
* 两根指针算法的时间复杂度一般为`O(n)`

* `C++`判断字符是否是数字或字母、大小写转换
  * 头文件：`#include <cctype>`
  * `isalpha()`函数
    * 判断一个字符是否是字母，若是则返回非零，若不是则返回零
  * `isdigit()`函数
    * 判断一个字符是否是数字，若是则返回非零，若不是则返回零
  * `isalnum()`函数
    * 判断一个字符是否是字母或数字，若是则返回非零，若不是则返回零
  * `islower()`函数
    * 判断一个字符是否是小写字母，若是则返回非零，若不是则返回零
  * `isupper()`函数
    * 判断一个字符是否是大写字母，若是则返回非零，若不是则返回零
  * `tolower()`函数
    * 将大写字母转化为小写字母，返回对应的整数
    * 若输入字符不是大写字母，则返回输入字符对应的整数
  * `toupper()`函数
    * 将小写字母转化为大写字母，返回对应的整数
    * 若输入字符不是小写字母，则返回输入字符对应的整数
## 快排(Quick Sort)
* 分而治之(Divide and Conquer)
  * 将序列分为两个子序列
    * $S = S_L + S_R$ // O(n) 寻找轴点的过程
    * 注：前一子序列$S_L$的任一元素在数值上都不超过后一子序列$S_R$的元素
  * 在子序列分别**递归**地排序之后，原序列自然有序
    * $sorted(S) = sorted(S_L) + sorted(S_R)$
  * 递归基
    * 单元素子序列
  * 归并排序的计算量和难点在于**合**，而快速排序在于**分**
* 轴点(Pivot)
  * 定义：左/右侧的元素，均不比它更大/小
  * 以轴点为界，原序列的划分自然实现
    * $[l_o, h_i) = [l_o, m_i) + [mi] + [m_i+1, h_i)$
