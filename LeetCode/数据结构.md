* 大纲(Outline)
  * 栈(Stack)
    * 应用
  * 哈希表(Hash)
    * 原理
    * 应用
  * 堆(Heap)
    * 原理
    * 应用
      * 优先级队列(Priority Queue)
    * 替代品
      * TreeMap
* 数据结构(Data Structure)
  * 可看作为一个集合，并且提供集合上的若干操作
* 队列(Queue)
  * 操作
    * Push：`O(1)`
    * Pop：`O(1)`
    * Top：`O(1)`
  * `BFS`的主要数据结构
* 栈(Stack)
  * 操作
    * Push：`O(1)`
    * Pop：`O(1)`
    * Top：`O(1)`
  * 非递归实现`DFS`的主要数据结构
* 哈希表(Hash)
  * 操作
    * Insert：`O(1)`
    * Delete：`O(1)`
    * Find：`O(1)`
  * `Hash Function`
    * 对于任意的key，得到一个**固定且无规律**的介于`0~capacity-1`的整数
    * 著名的哈希算法
      * MD5
      * SHA-1
      * SHA-2
  * `Collision`
    * Open Hashing
      * 经常使用
      * [开放散列](https://www.cs.usfca.edu/~galles/visualization/OpenHash.html)
    * Closed Hashing
      * [封闭散列](https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html)
    * 再好的`hash function`也会存在**冲突**
  * `Rehashing`
    * 哈希表存储的元素太多（如超过容量的十分之一），将哈希表容量扩大一倍，并将所有的哈希值重新安排
```
int hashFunc(string key) {
    return md5(key) % HASH_TABLE_SIZE;
}

int hashFunc(string key) {
    int sum = 0;
    for (int i = 0; i < key.size(); ++i) {
        sum = sum * 31 + (int)(key[i]);
        sum = sum % HASH_TABLE_SIZE;
    }
    return sum;
}
```
* 堆(Heap)
  * 操作
    * Add：`O(logn)`
    * Remove：`O(logn)`
    * Min/Max：`O(1)`
  * Max Heap vs Min Heap
## 强化班
* Overview
  * 数据结构
    * 数据之间的关系，好的关系可以使得数据处理起来更加高效
  * 并查集(Union Find)
  * 字典树(Trie)



# 例题
## 字符串解码(Expression Expand)
* 问题的描述
  * 给定一个表达式`s`，包括数字、字母及方括号
  * 在方括号前的数字表示方括号内容的重复次数（方括号内的内容可以是字符串或者另一个表达式）
  * 问题：将这个表达式展开成一个字符串
* 测例
  * 测例1
    * 输入：`S = abc3[a]`
    * 输出：`abcaaa`
  * 测例2
    * 输入：`S = 3[abc]`
    * 输出：`abcabcabc`
  * 测例3
    * 输入：`4[ac]dy`
    * 输出：`acacacacdy`
  * 测例4
    * 输入：`3[2[ad]3[pf]]xyz`
    * 输出：`adadpfpfpfadadpfpfpfadadpfpfpfxyz`
* 问题的解答
  * 思路
  * 复杂度分析
    * 时间复杂度
    * 空间复杂度
  * 代码
```
// version 1: Stack
class Solution {
public:
    string expressionExpand(string& s) {
        stack<char> stk;
        stack<int> stknum;
        int number = 0;
        
        for (int i = 0;i < s.size(); ++i) {
            if (s[i] >= '0' && s[i] <= '9') {
                number = number * 10 + s[i] - '0';
            } else if (s[i] == '[') {
                stknum.push(number);
                stk.push('[');
                number = 0;
            } else if (s[i] == ']') {
                string newStr = popStack(stk);
                int count = stknum.top();
                stknum.pop();
                for (int j = 0; j < count; ++j) {
                    for (int k = 0; k < newStr.size(); ++k) {
                        stk.push(newStr[k]);
                    }
                }
            } else {
                stk.push(s[i]);
            }
        }
        
        return popStack(stk);
    }
    
    string popStack(stack<char>& stk) {
        stack<char> buffer;
        while (!stk.empty() && stk.top() != '[') {
            buffer.push(stk.top());
            stk.pop();
        }
        if (!stk.empty() && stk.top() == '[') stk.pop();
        string s = "";
        while (!buffer.empty()) {
            s += buffer.top();
            buffer.pop();
        }
        return s;
    }
};
```
